CKEDITOR.replace('editor1', { contentsCss: 'body {color:#000; background-color#:FFF;}', docType: '<!DOCTYPE HTML>', coreStyles_bold: { element: 'b' }, coreStyles_italic: { element: 'i' }, coreStyles_underline: { element: 'u' }, coreStyles_strike: { element: 'strike' }, font_style: { element: 'font', attributes: { 'face': '#(family)'} }, fontSize_sizes: 'xx-small/1;x-small/2;small/3;medium/4;large/5;x-large/6;xx-large/7', fontSize_style: { element: 'font', attributes: { 'size': '#(size)'} }, colorButton_enableMore: true, colorButton_foreStyle: { element: 'font', attributes: { 'color': '#(color)'} }, colorButton_backStyle: { element: 'font', styles: { 'background-color': '#(color)'} }, stylesSet: [{ name: 'Computer Code', element: 'code' }, { name: 'Keyboard Phrase', element: 'kbd' }, { name: 'Sample Text', element: 'samp' }, { name: 'Variable', element: 'var' }, { name: 'Deleted Text', element: 'del' }, { name: 'Inserted Text', element: 'ins' }, { name: 'Cited Work', element: 'cite' }, { name: 'Inline Quotation', element: 'q'}], on: { 'instanceReady': configureHtmlOutput} }); function configureHtmlOutput(ev) { var editor = ev.editor, dataProcessor = editor.dataProcessor, htmlFilter = dataProcessor && dataProcessor.htmlFilter; dataProcessor.writer.selfClosingEnd = '>'; var dtd = CKEDITOR.dtd; for (var e in CKEDITOR.tools.extend({}, dtd.$nonBodyContent, dtd.$block, dtd.$listItem, dtd.$tableContent)) { dataProcessor.writer.setRules(e, { indent: true, breakBeforeOpen: true, breakAfterOpen: false, breakBeforeClose: !dtd[e]['#'], breakAfterClose: true }) } htmlFilter.addRules({ elements: { $: function (element) { if (element.name == 'img') { var style = element.attributes.style; if (style) { var match = /(?:^|\s)width\s*:\s*(\d+)px/i.exec(style), width = match && match[1]; match = /(?:^|\s)height\s*:\s*(\d+)px/i.exec(style); var height = match && match[1]; if (width) { element.attributes.style = element.attributes.style.replace(/(?:^|\s)width\s*:\s*(\d+)px;?/i, ''); element.attributes.width = width } if (height) { element.attributes.style = element.attributes.style.replace(/(?:^|\s)height\s*:\s*(\d+)px;?/i, ''); element.attributes.height = height } } } if (element.name == 'p') { style = element.attributes.style; if (style) { match = /(?:^|\s)text-align\s*:\s*(\w*);/i.exec(style); var align = match && match[1]; if (align) { element.attributes.style = element.attributes.style.replace(/(?:^|\s)text-align\s*:\s*(\w*);?/i, ''); element.attributes.align = align } } } if (!element.attributes.style) delete element.attributes.style; return element } }, attributes: { style: function (value, element) { return convertRGBToHex(value) } } }) } function convertRGBToHex(cssStyle) { return cssStyle.replace(/(?:rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\))/gi, function (match, red, green, blue) { red = parseInt(red, 10).toString(16); green = parseInt(green, 10).toString(16); blue = parseInt(blue, 10).toString(16); var color = [red, green, blue]; for (var i = 0; i < color.length; i++) color[i] = String('0' + color[i]).slice(-2); return '#' + color.join('') }) }